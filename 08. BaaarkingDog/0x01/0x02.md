## 알아두면 좋은 점

512MB = 524288kb = 536,870,912byte(약 5억) 이므로<br>
메모리 제한이 512MB일 때, 4byte인 int형 변수를 약 1.2억개 정도 선언할 수 있다.<br>
따라서, 만약 떠올린 풀이가 '크기가 5억인 배열'을 필요로 한다면 해당 풀이는 틀렸다는 것을 코딩 전에 미리 알 수 있다.
<br><br><br>

## 실수 자료형

실수를 나타낼 때 칸이 다음과 같이 나누어진다.

### IEEE-754 format

| 자료형   | 부호(bit) | 과학적 표기법에서의 지수(bit)  | 유효숫자 부분(bit)   |
| -------- | --------- | ------------------------------ | -------------------- |
| `float`  | sign(1)   | exponent(8)                    | fraction(23)         |
| `double` | sign(1)   | exponent(11)                   | fraction(52)         |
| -6.75    | (음수)1   | (2의 지수 2 + 127=129)10000001 | (1.1011-1)1011000…00 |

### 상대 오차 범위

-   `float` : 상대 오차 10^-6까지 (6자리)
-   `double`: 상대 오차 10^-15까지 (15자리)
-   실수의 연산 과정에서 오차가 생기는 것 자체는 막을 수 없지만, 오차가 어느 정도인지는 알 수 있다.
-   두 자료형의 허용 범위의 차이가 굉장히 크기 때문에, 실수 자료형이 필요하다면 `double`을 사용하자.
    <br><br><br>

## double에 long long 범위의 정수를 함부로 담으면 안 된다

`double`은 유효숫자 15자리, `long long`은 최대 19자리이다.<br>
따라서 더 큰 자료형인 `long long`을 `double`에 담으면 10^18+1과 10^18을 구분하지 못해서 그냥 같은 값이 저장되고 만다. (오차가 섞인 값이 저장된다.)
<br><br><br>

## 실수를 비교할 때는 등호를 사용하면 안 된다

오차가 발생할 수 있기 때문에, 두 실수가 같은지 알고 싶을 때에는 차이가 아주 작을 때 동일하다고 처리한다.<br>
동일하다고 처리하는 오차의 기준은 1e-12(10^-12) 이하이다.
