## 배열이란?

-   메모리 상에 원소를 연속하게 배치한 자료구조

## 배열의 성질

1. O(1)에 k번째 원소를 확인/변경 가능

-   메모리 상에 원소를 연속하게 배치한 자료구조이므로, k번째 원소의 위치를 바로 계산할 수 있다.
-   시작 주소에서 k칸만큼 오른쪽으로 가면 끝.
    <br>

2. 추가적으로 소모되는 메모리의 양(overhead)이 거의 없음

-   이후 다른 자료구조를 배우고 나면 이해할 수 있을지도?
    <br>

3. **Cache hit rate**가 높음
   <br>
4. 메모리 상에 연속한 구간을 잡아야 하므로, 할당에 제약이 있음

## 배열의 기능

| 배열의 기능                      | 시간복잡도 |
| -------------------------------- | ---------- |
| 임의의 위치의 원소를 확인 / 변경 | `O(1)`     |
| 배열의 마지막 원소를 추가 / 제거 | `O(1)`     |
| 임의의 위치에 원소를 추가 / 제거 | `O(N)`     |

-   시간복잡도를 헷갈리지 않도록 잘 기억하는 것이 좋다.

## 배열 사용 팁

-   배열 전체 요소를 특정 값으로 초기화시킬 때, 효율적인 방법은?

1. `<cstring>` 헤더의 `memset()` 함수 활용하기

-   장점: **짧다.**
-   단점: **실수의 여지가 많다.** <br>
    0이나 -1이 아닌 값을 넣으면 오작동하거나, 2차원 이상의 배열을 함수의 인자로 넘긴 후 그 곳에서 memset()을 사용하면 잘못 들어가는 등...

2. `for문`으로 배열 요소의 값을 하나하나 바꾸기

-   장점: **실수할 여지가 없다.**
-   단점: **코드가 투박해진다.**

3. `<algorithm>` 헤더의 `fill()` 함수 활용하기

-   장점: **실수할 여지가 없고, 짧다.**
-   단점: **익숙해질 필요가 있다.**

## [STL vector](https://www.cplusplus.com/reference/vector/vector/)

-   배열과 거의 동일함
-   배열과 달리, 크기를 자유자재로 늘릴 수 있다.
-   '인접 리스트'라는 것을 저장할 때 편하다. (인접 리스트를 배우기 전까진, [vector](https://www.cplusplus.com/reference/vector/vector/)를 쓸 일은 딱히 없지만, 그래도 알아두면 좋다!)

### vector의 예제

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> v1(3, 5); // {5, 5, 5};
    cout << v1.size() << '\n'; // 3
    v1.push_back(7); // {5, 5, 5, 7};

    vector<int> v2(2); // {0, 0};
    v2.insert(v2.begin() + 1, 3); // {0, 3, 0};

    vector<int> v3 = {1, 2, 3, 4}; // {1, 2, 3, 4}
    v3.erase(v3.begin() + 2) // {1, 2, 4};

    vector<int> v4; // {}
    v4 = v3; // {1, 2, 4}
    cout << v4[0] << v4[1] << v4[2] << '\n'; // 124
    v4.pop_back(); // {1, 2}
    v4.clear(); // {}

    return 0;
}
```

| 메소드명                          | 시간복잡도 |
| --------------------------------- | ---------- |
| `.insert()`<br>`.erase()`         | `O(N)`     |
| `.push_back()`<br>`.pop_back()`   | `O(1)`     |
| `.push_front()`<br>`.pop_front()` | `O(N)`     |

-   STL의 iterator에 대해 추가로 공부해 보자
-   메소드의 시간복잡도를 헷갈리지 말고, 잘 생각해 보자

## [range-based for loop](https://phthalos.github.io/algorithm/10808/)

-   C++11부터 추가된 기능

```c++
vector<int> v1 = {1, 2, 3, 4, 5, 6};

for(int e : v1)
    cout << e << ' ';
```

-   [vector](https://www.cplusplus.com/reference/vector/vector/)는 크기를 자유롭게 늘리거나 줄일 수 있는 배열이다.
-   위 코드와 같이 선언했을 때, e에 v1의 원소들이 순서대로 하나씩 들어가는 for문이 된다.
-   함수에 인자를 넣을 때와 같이, 기본적으로 e에는 복사된 요소가 들어가지만, `int&e : v1`과 같이 **참조자**를 사용하면 e에 v1의 원본 값이 대입된다.
